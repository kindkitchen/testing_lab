{"version":3,"sources":["../src/make_fixture.ts"],"sourcesContent":["export const make_fixture = {\n  /**\n   * A lot of properties are syntax sugar with purpose\n   * to simplify process of constructing pretty difficult\n   * internal data-structure for fixture. Also it may\n   * help to understand main ideas and purposes with which\n   * it was developed.\n   */\n  start_builder_chain: {\n    /**\n     * The shape of the data source\n     *\n     * This type is represent the all values,\n     * that can be used in dto, entities, models, etc.\n     * which will be produced from same source.\n     * Example:\n     * The single data-set associated with user can be used\n     * for user creation, user updates, view full or compact\n     * user's representation, etc.\n     * ```\n     * make_fixture.for_data_type<{\n     *   id: string;\n     *   name: string;\n     *   age: number;\n     * }>() /// ...rest code\n     * ```\n     * #### Important!\n     * **This is generic type, that you should provide and nothing more**\n     */\n    for_data_type: <\n      T_data extends\n        | Record<string, any>\n        | _T_help_message_for_data_type = _T_help_message_for_data_type,\n    >(\n      ..._warning: T_data extends _T_help_message_for_data_type\n        ? [_T_help_message_for_data_type, never]\n        : []\n    ) => {\n      return {\n        /**\n         * Next generic only helper, that should extend\n         * `string` type, for example:\n         * ```\n         * .with_possible_tags<\"all\", \"verified_only\", \"men\">\n         * ```\n         * These tags will be used to mark fixtures and so have ability\n         * to group them by some criteria. Because this is tag - fixture\n         * can be belong to many groups at once.\n         *\n         * **At this moment though - you should simply register all possible variants\n         * for better typescript inference**\n         */\n        with_possible_tags: (<\n          T_tags extends (\n            | string\n            | _T_help_message_with_possible_tags\n          ) = _T_help_message_with_possible_tags,\n        >(\n          ..._warning: T_tags extends _T_help_message_with_possible_tags | \"\"\n            ? [_T_help_message_with_possible_tags, never]\n            : []\n        ) => {\n          type TD = Partial<\n            Exclude<T_data, _T_help_message_for_data_type | undefined>\n          >;\n\n          type TT = Exclude<T_tags, _T_help_message_with_possible_tags | \"\">;\n\n          return {\n            /**\n             * This is object, in which each property is represented\n             * particular dto/entity/view or state of your data.\n             * For example data, associated with user can contain many\n             * properties, but during creation you skip `id` and so on.\n             * The value of each property is a function - that should\n             * transform initial data to some form.\n             * Example:\n             * ```\n             * {\n             *    create_user_dto: (data) => ({ : data.email }),\n             *    update_user_dto: (data) => ([data.id, ])\n             * }\n             * ```\n             */\n            data_can_be_transformed_into_such_views: <\n              T_transformer extends Record<\n                string,\n                (d: TD, ...params: any[]) => any\n              >,\n            >(transformer: T_transformer) => {\n              type T_as_arr = {\n                [k in keyof T_transformer]: (\n                  ...params: FirstRest<Parameters<T_transformer[k]>>[1]\n                ) => () => ReturnType<T_transformer[k]>[];\n              };\n              type T_as = {\n                [k in keyof T_transformer]: (\n                  ...params: FirstRest<Parameters<T_transformer[k]>>[1]\n                ) => () => ReturnType<T_transformer[k]>;\n              };\n              return {\n                /**\n                 * Complete building fixture-set by providing\n                 * implementation.\n                 * Each property is fixture-wrapper, with fixture itself\n                 * and all tags associated with this fixture.\n                 */\n                build: <\n                  T_fixture_set extends Record<\n                    string,\n                    { fixture: TD; tags: TT[] }\n                  >,\n                >(fixture_set: T_fixture_set): {\n                  /**\n                   * Api to manage one unique fixture.\n                   */\n                  one_by_name: (name: keyof T_fixture_set) => {\n                    /**\n                     * Generate representation of data, that you declared during build.\n                     * You will get not directly this representation, function: `() => representation`.\n                     * So until logic of the representation is the same it will automatically produce\n                     * it with actual values from data-source.\n                     */\n                    as: T_as;\n                    /**\n                     * Mark this fixture with some tags.\n                     * No matter does it is already marked by them or not, but\n                     * from now it will.\n                     */\n                    add_to_more_tags: (...tag: TT[]) => void;\n                    /**\n                     * Remove from fixture associations with ome tags.\n                     * No matter does it is already marked by them or not, but\n                     * from not it will not.\n                     */\n                    remove_from_tags: (...tag: TT[]) => void;\n                    /**\n                     * The only one correct way to update fixture's data.\n                     */\n                    update_data_source: (\n                      /**\n                       * Your custom logic how to produce new data from previous varian.\n                       * Because it is function - you can do this with any custom logic\n                       * or even skip update because of some condition, though in such case you should\n                       * return input as it is...\n                       * So the rule is simple - data will be updated to whatever your function return.\n                       */\n                      update_logic: (d: TD) => TD,\n                    ) => void;\n                  };\n                  /**\n                   * Api for manage list of fixtures with some tag.\n                   */\n                  many_with_tag: (tag: TT) => {\n                    /**\n                     * Generate array with representations for all fixtures marked by some tag.\n                     * It is also will return not directly array with these views but function,\n                     * that will produce it. This will guarantee, that on each call\n                     * the representations will have actual values from data-source.\n                     */\n                    as: T_as_arr;\n                    /**\n                     * Possibility to update all fixtures associated with\n                     * actual tag. Because this is function, any logic, including\n                     * skip during update can be implement.\n                     * The only rule - return value is one that will become new data-source.\n                     */\n                    foreach_update_data_source: (\n                      /**\n                       * Custom logic of update, that will be applied to all\n                       * fixtures under the current tag.\n                       */\n                      update_logic: (d: TD) => TD,\n                    ) => void;\n                  };\n                } => {\n                  let last_id = Date.now();\n                  const db = Object\n                    .entries(fixture_set)\n                    .reduce(\n                      (acc, [name, { fixture, tags }]) => {\n                        const id = ++last_id;\n                        acc.id_fixture.set(id, fixture);\n                        acc.name_tag_fixture.set(\n                          name,\n                          new Map(tags.map((t) => [t, id])),\n                        );\n                        acc.name_fixture.set(name, id);\n                        for (const tag of tags) {\n                          (acc.tag_name_fixture.get(tag) ||\n                            acc.tag_name_fixture.set(tag, new Map()).get(tag)!)\n                            .set(name, id);\n                        }\n\n                        return acc;\n                      },\n                      {\n                        id_fixture: new Map<number, TD>(),\n                        name_fixture: new Map<string, number>(),\n                        name_tag_fixture: new Map<\n                          string,\n                          Map<string, number>\n                        >(),\n                        tag_name_fixture: new Map<\n                          string,\n                          Map<string, number>\n                        >(),\n                      },\n                    );\n\n                  return {\n                    one_by_name: (name) => ({\n                      add_to_more_tags: (...tags) =>\n                        tags.forEach((tag) => {\n                          const fixture = db.name_fixture.get(name as string)!; /// 100% exists because all fixtures are provided at once;\n                          (db.name_tag_fixture.get(name as string) ||\n                            db.name_tag_fixture.set(name as string, new Map())\n                              .get(name as string)!)\n                            .set(\n                              tag,\n                              fixture,\n                            );\n                          (db.tag_name_fixture.get(tag) ||\n                            db.tag_name_fixture.set(tag, new Map()).get(tag)!)\n                            .set(\n                              name as string,\n                              fixture,\n                            );\n                        }),\n                      remove_from_tags: (...tags) =>\n                        tags.forEach((tag) => {\n                          db.name_tag_fixture.get(name as string)!.delete(tag);\n                          db.tag_name_fixture.get(tag)!.delete(name as string);\n                        }),\n                      update_data_source: (logic) => {\n                        const id = db.name_fixture.get(name as string)!;\n                        const fixture = db.id_fixture.get(id)!;\n                        const fresh = logic(\n                          fixture,\n                        );\n                        db.id_fixture.set(id, fresh);\n                      },\n                      as: Object.entries(transformer).reduce((acc, [k, v]) => {\n                        acc[k as keyof T_transformer] = (...args) => () => {\n                          const id = db.name_fixture.get(name as string)!;\n                          return v(\n                            db.id_fixture.get(id)!,\n                            ...args,\n                          );\n                        };\n                        return acc;\n                      }, {} as T_as),\n                    }),\n                    many_with_tag: (tag) => ({\n                      as: Object.entries(transformer).reduce((acc, [k, fn]) => {\n                        acc[k as keyof T_transformer] = () => (...args) => {\n                          const views = (db.tag_name_fixture.get(tag) || [])\n                            .values()\n                            .toArray().map((id) =>\n                              fn(db.id_fixture.get(id)!, ...args)\n                            );\n                          return views;\n                        };\n                        return acc;\n                      }, {} as T_as_arr),\n                      foreach_update_data_source: (logic) => {\n                        (db.tag_name_fixture.get(tag) ||\n                          new Map<string, number>()).entries()\n                          .toArray()\n                          .forEach(([_, v]) => {\n                            const fixture = db.id_fixture.get(v)!;\n                            db.id_fixture.set(v, logic(fixture));\n                          });\n                      },\n                    }),\n                  };\n                },\n              };\n            },\n          };\n        }),\n      };\n    },\n  },\n};\n\ntype FirstRest<T> = T extends [infer First, ...infer Rest] ? [First, Rest]\n  : never;\ntype _T_help_message_for_data_type =\n  \"ERROR: Explicit generic is missing! Should be something like: for_data_type<{...}>()\";\ntype _T_help_message_with_possible_tags =\n  \"ERROR: Explicit generic is missing! Should be something like: with_possible_tags<['example', 'demo', 'tip']>()\";\n"],"mappings":"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","names":["make_fixture_exports","__export","make_fixture","__toCommonJS","_warning","transformer","fixture_set","last_id","db","acc","name","fixture","tags","id","t","tag","logic","fresh","k","v","args","fn","_"]}